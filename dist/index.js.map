{"version":3,"file":"index.js","sources":["../src/game/constants/colors.ts","../src/game/constants/shapes.ts","../src/game/core/Shape.ts","../src/game/core/Board.ts","../src/game/core/KeyHandler.ts","../src/game/core/GameHandler.ts","../src/game/index.ts","../src/ai/index.ts","../src/ai/core/AI.ts"],"sourcesContent":["const colors = [\r\n  \"#00f0f0\",\r\n  \"#0000f5\",\r\n  \"#f0a000\",\r\n  \"#f0f000\",\r\n  \"#00f000\",\r\n  \"#a000f0\",\r\n  \"#f00000\",\r\n] as const;\r\n\r\nexport default colors;\r\n","type ShapeMatrix = number[][];\r\n\r\nconst shapes: ShapeMatrix[] = [\r\n  [[1, 1, 1, 1]],\r\n  [\r\n    [2, 0, 0],\r\n    [2, 2, 2],\r\n  ],\r\n  [\r\n    [0, 0, 3],\r\n    [3, 3, 3],\r\n  ],\r\n  [\r\n    [4, 4],\r\n    [4, 4],\r\n  ],\r\n  [\r\n    [0, 5, 5],\r\n    [5, 5, 0],\r\n  ],\r\n  [\r\n    [0, 6, 0],\r\n    [6, 6, 6],\r\n  ],\r\n  [\r\n    [7, 7, 0],\r\n    [0, 7, 7],\r\n  ],\r\n];\r\n\r\nexport default shapes;\r\n","import shapes from \"../constants/shapes\";\r\nimport Board from \"./Board\";\r\n\r\nclass Shape {\r\n  /**\r\n   * we want to be able to do a last action when the shape can't go down anymore\r\n   * 0 we can do anything\r\n   * 1 we can do anything except going down\r\n   * > 1 we can't do anything\r\n   */\r\n  private downTick = 0;\r\n\r\n  constructor(\r\n    private board: Board,\r\n    private shape: number[][],\r\n    private position: { x: number; y: number } = null\r\n  ) {\r\n    if (!this.position) {\r\n      this.position = {\r\n        x: Math.floor(this.board.getWidth() / 2 - this.shape[0].length / 2),\r\n        y: -this.shape.length,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a random shape\r\n   * @param board\r\n   * @returns\r\n   */\r\n  static randomShape(board: Board) {\r\n    const rndShape = shapes[Math.floor(Math.random() * shapes.length)];\r\n    return new Shape(board, rndShape);\r\n  }\r\n\r\n  /**\r\n   * Rotate the shape in clockwise with 90 degrees\r\n   * @returns\r\n   */\r\n  rotate() {\r\n    const matrix = this.shape;\r\n\r\n    const numRows = matrix.length;\r\n    const numCols = matrix[0].length;\r\n    const rotated: number[][] = [];\r\n\r\n    for (let col = 0; col < numCols; col++) {\r\n      const newRow: number[] = [];\r\n      for (let row = numRows - 1; row >= 0; row--) {\r\n        newRow.push(matrix[row][col]);\r\n      }\r\n      rotated.push(newRow);\r\n    }\r\n\r\n    const newY =\r\n      this.position.y +\r\n      Math.floor(this.shape.length / 2) -\r\n      Math.floor(rotated.length / 2);\r\n    const newX =\r\n      this.position.x +\r\n      Math.floor(this.shape[0].length / 2) -\r\n      Math.floor(rotated[0].length / 2);\r\n\r\n    const canRotateX =\r\n      newX + rotated[0].length <= this.board.getWidth() && newX >= 0;\r\n    const canRotateY = newY + rotated.length <= this.board.getHeight();\r\n\r\n    if (canRotateX && canRotateY) {\r\n      //TODO (Optimisation): Make the rotation better without that much loop\r\n      //Run well so not that much a big priority\r\n      const board = structuredClone(this.board.getBoard());\r\n\r\n      //We simulate the removing of the original shape\r\n      for (let i = 0; i < this.shape.length; ++i) {\r\n        for (let j = 0; j < this.shape[i].length; ++j) {\r\n          if (this.position.y + i >= 0)\r\n            board[i + this.position.y][j + this.position.x] = 0;\r\n        }\r\n      }\r\n\r\n      //checking we dont make conflict with other shapes\r\n      for (let i = 0; i < rotated.length; ++i) {\r\n        for (let j = 0; j < rotated[i].length; ++j) {\r\n          if (newY + i >= 0 && board[i + newY][j + newX] !== 0) return;\r\n        }\r\n      }\r\n\r\n      this.position.y = newY;\r\n      this.position.x = newX;\r\n      this.shape = rotated;\r\n    }\r\n\r\n    this.board.update(false);\r\n  }\r\n\r\n  /**\r\n   * Check if the shape can go on the left\r\n   * @returns\r\n   */\r\n  canGoLeft() {\r\n    const shape = this.shape;\r\n    const position = this.position;\r\n    const board = this.board.getBoard();\r\n\r\n    for (let i = 0; i < shape.length; ++i) {\r\n      for (let j = 0; j < shape[i].length; ++j) {\r\n        const isIntersectingLeft =\r\n          position.y + i >= 0 &&\r\n          (shape[i][j - 1] === 0 || shape[i][j - 1] === undefined) &&\r\n          board[i + position.y]?.[j + position.x - 1] !== 0 &&\r\n          position.x !== 0;\r\n\r\n        if (isIntersectingLeft && shape[i][j] !== 0) return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Check if the shape can go on the right\r\n   * @returns\r\n   */\r\n  canGoRiht() {\r\n    const shape = this.shape;\r\n    const position = this.position;\r\n    const board = this.board.getBoard();\r\n\r\n    for (let i = 0; i < shape.length; ++i) {\r\n      for (let j = 0; j < shape[i].length; ++j) {\r\n        const isIntersectingRight =\r\n          position.y + i >= 0 &&\r\n          (shape[i][j + 1] === 0 || shape[i][j + 1] === undefined) &&\r\n          board[i + position.y]?.[j + position.x + 1] !== 0 &&\r\n          position.x !== this.board.getWidth() - shape[0].length;\r\n\r\n        if (isIntersectingRight && shape[i][j] !== 0) return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Check if the shape can go down\r\n   * @returns\r\n   */\r\n  canGoDown() {\r\n    if (this.haveReachedBottom()) {\r\n      ++this.downTick;\r\n      return this.downTick <= 1;\r\n    }\r\n\r\n    const shape = this.shape;\r\n    const position = this.position;\r\n    const board = this.board.getBoard();\r\n\r\n    for (let i = 0; i < shape.length; ++i) {\r\n      for (let j = 0; j < shape[i].length; ++j) {\r\n        const isIntersectingDown =\r\n          position.y + i + 1 >= 0 &&\r\n          (shape[i + 1]?.[j] === 0 || shape[i + 1]?.[j] === undefined) &&\r\n          board[i + position.y + 1]?.[j + position.x] !== 0;\r\n\r\n        if (isIntersectingDown && shape[i][j] !== 0) {\r\n          ++this.downTick;\r\n          return this.downTick <= 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.downTick = 0;\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Make the shape go down\r\n   */\r\n  goDown() {\r\n    if (\r\n      this.position.y !== this.board.getHeight() - this.shape.length &&\r\n      this.downTick === 0\r\n    )\r\n      ++this.position.y;\r\n    this.board.update(false);\r\n  }\r\n\r\n  /**\r\n   * Make the shape go on the right\r\n   * @returns\r\n   */\r\n  goRight() {\r\n    if (!this.canGoRiht()) return;\r\n\r\n    if (this.position.x !== this.board.getWidth() - this.shape[0].length)\r\n      ++this.position.x;\r\n    this.board.update(false);\r\n  }\r\n\r\n  /**\r\n   * Make the shape go on the left\r\n   * @returns\r\n   */\r\n  goLeft() {\r\n    if (!this.canGoLeft()) return;\r\n\r\n    if (this.position.x !== 0) this.position.x--;\r\n    this.board.update(false);\r\n  }\r\n\r\n  /**\r\n   * Check if we have reached bottom of the board and cant go down anymore\r\n   * @returns\r\n   */\r\n  haveReachedBottom() {\r\n    return this.position.y === this.board.getHeight() - this.shape.length;\r\n  }\r\n\r\n  getShape() {\r\n    return this.shape;\r\n  }\r\n\r\n  getPosition() {\r\n    return this.position;\r\n  }\r\n\r\n  /**\r\n   * Create a copy of the shape\r\n   * @returns\r\n   */\r\n  copy() {\r\n    return new Shape(this.board, this.shape, structuredClone(this.position));\r\n  }\r\n}\r\n\r\nexport default Shape;\r\n","import Shape from \"./Shape\";\r\n\r\nclass Board {\r\n  private board: number[][] = [];\r\n\r\n  private score = 0;\r\n\r\n  private actualShape = Shape.randomShape(this);\r\n  private nextShape = Shape.randomShape(this);\r\n  private backShape: Shape;\r\n\r\n  constructor(private width = 12, private height = 24) {\r\n    this.buildBoard();\r\n  }\r\n\r\n  /**\r\n   * Build the board\r\n   */\r\n  private buildBoard() {\r\n    for (let i = 0; i < this.width * this.height; ++i) {\r\n      if (i % this.width === 0) this.board.push([]);\r\n      this.board[this.board.length - 1].push(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove the last position of the actual shape from the board\r\n   * @returns\r\n   */\r\n  removeLastShapeDraw() {\r\n    if (!this.backShape) return;\r\n\r\n    const shape = this.backShape.getShape();\r\n    const position = this.backShape.getPosition();\r\n\r\n    for (let i = 0; i < shape.length; ++i) {\r\n      for (let j = 0; j < shape[i].length; ++j) {\r\n        if (position.y + i < 0) continue;\r\n        if (shape[i][j] !== 0) this.board[i + position.y][j + position.x] = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the actual shape to the board\r\n   */\r\n  displayShape() {\r\n    const shape = this.actualShape.getShape();\r\n    const position = this.actualShape.getPosition();\r\n\r\n    for (let i = 0; i < shape.length; ++i) {\r\n      for (let j = 0; j < shape[i].length; ++j) {\r\n        if (position.y + i < 0) continue;\r\n        if (shape[i][j] !== 0)\r\n          this.board[i + position.y][j + position.x] = shape[i][j];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the game is loose\r\n   * @returns\r\n   */\r\n  haveLoose() {\r\n    const topLine = this.board[0];\r\n    return topLine.some((col) => col !== 0) && !this.actualShape.canGoDown();\r\n  }\r\n\r\n  /**\r\n   * Get the score from the completed lines as the same moment\r\n   * @param completedLines\r\n   * @returns\r\n   */\r\n  getScoreFromCompletedLine(completedLines: number) {\r\n    switch (completedLines) {\r\n      case 0:\r\n        return 0;\r\n      case 1:\r\n        return 40;\r\n      case 2:\r\n        return 100;\r\n      case 3:\r\n        return 300;\r\n      default:\r\n        return 1200;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove completed lines and set the score based on it\r\n   */\r\n  removeCompletedLines() {\r\n    let completedLines = 0;\r\n\r\n    for (let i = 0; i < this.board.length; ++i) {\r\n      const line = this.board[i];\r\n\r\n      const lineCompleted = line.every((col) => col !== 0);\r\n\r\n      if (!lineCompleted) continue;\r\n\r\n      ++completedLines;\r\n      this.board.splice(i, 1);\r\n      this.board.unshift(Array(this.width).fill(0));\r\n    }\r\n\r\n    this.score += this.getScoreFromCompletedLine(completedLines);\r\n  }\r\n\r\n  /**\r\n   * Update the board (make shape go down, ...)\r\n   * @param goDown\r\n   */\r\n  update(goDown = true) {\r\n    this.removeLastShapeDraw();\r\n\r\n    if (!this.actualShape.canGoDown()) {\r\n      this.score += this.actualShape.getShape().length + 1; //We had the numbers of rows + 1 to the score\r\n      this.displayShape();\r\n      this.removeCompletedLines();\r\n      this.actualShape = this.nextShape;\r\n      this.nextShape = Shape.randomShape(this);\r\n    }\r\n\r\n    this.backShape = this.actualShape.copy();\r\n\r\n    if (goDown) this.actualShape.goDown();\r\n\r\n    this.displayShape();\r\n  }\r\n\r\n  getScore() {\r\n    return this.score;\r\n  }\r\n\r\n  getBoard() {\r\n    return this.board;\r\n  }\r\n\r\n  getWidth() {\r\n    return this.width;\r\n  }\r\n\r\n  getHeight() {\r\n    return this.height;\r\n  }\r\n\r\n  getActualShape() {\r\n    return this.actualShape;\r\n  }\r\n\r\n  getNextShape() {\r\n    return this.nextShape;\r\n  }\r\n\r\n  getBackShape() {\r\n    return this.backShape;\r\n  }\r\n\r\n  setActualShape(shape: Shape) {\r\n    this.actualShape = shape;\r\n  }\r\n\r\n  setNextShape(shape: Shape) {\r\n    this.nextShape = shape;\r\n  }\r\n\r\n  setBackShape(shape: Shape) {\r\n    this.backShape = shape;\r\n  }\r\n\r\n  setBoard(board: number[][]) {\r\n    this.board = board;\r\n  }\r\n\r\n  setScore(score: number) {\r\n    this.score = score;\r\n  }\r\n\r\n  /**\r\n   * Reset the board\r\n   */\r\n  reset() {\r\n    this.board = [];\r\n\r\n    this.actualShape = Shape.randomShape(this);\r\n    this.nextShape = Shape.randomShape(this);\r\n    this.backShape = null;\r\n\r\n    this.score = 0;\r\n\r\n    this.buildBoard();\r\n  }\r\n\r\n  /**\r\n   * Create a deep copy of the board\r\n   * @returns\r\n   */\r\n  copy() {\r\n    const copy = new Board(this.width, this.height);\r\n    copy.setActualShape(this.actualShape.copy());\r\n    copy.setNextShape(this.nextShape.copy());\r\n    copy.setBackShape(this.backShape.copy());\r\n    copy.setBoard(structuredClone(this.board));\r\n    copy.setScore(this.score);\r\n    return copy;\r\n  }\r\n}\r\n\r\nexport default Board;\r\n","import GameHandler from \"./GameHandler\";\r\n\r\ntype Keys = {\r\n  RIGHT: string;\r\n  DOWN: string;\r\n  LEFT: string;\r\n  ROTATE: string;\r\n};\r\n\r\nclass KeyHandler {\r\n  constructor(private gameHandler: GameHandler, private keys: Keys) {\r\n    this.initKeyListener();\r\n  }\r\n\r\n  /**\r\n   * Append key listener to the dom\r\n   */\r\n  initKeyListener() {\r\n    const board = this.gameHandler.getBoard();\r\n\r\n    document.addEventListener(\"keydown\", (event) => {\r\n      if (!this.gameHandler.isRunning()) return;\r\n\r\n      const key = event.key;\r\n      const cmd = Object.entries(this.keys).find(\r\n        (arr) => arr[1].toLocaleLowerCase() === key.toLocaleLowerCase()\r\n      );\r\n\r\n      if (cmd) {\r\n        const shape = board.getActualShape();\r\n\r\n        switch (cmd[0]) {\r\n          case \"RIGHT\":\r\n            shape.goRight();\r\n            break;\r\n          case \"LEFT\":\r\n            shape.goLeft();\r\n            break;\r\n          case \"DOWN\":\r\n            shape.goDown();\r\n            break;\r\n          case \"ROTATE\":\r\n            shape.rotate();\r\n            break;\r\n        }\r\n\r\n        this.gameHandler.drawGame();\r\n        if (board.haveLoose()) this.gameHandler.loose();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default KeyHandler;\r\n","import colors from \"../constants/colors\";\r\nimport Board from \"./Board\";\r\nimport KeyHandler from \"./KeyHandler\";\r\n\r\nenum GameStatus {\r\n  LOOSE = \"You loose\",\r\n  NOT_PLAYING = \"Not playing\",\r\n  PLAYING = \"Playing\",\r\n}\r\n\r\nconst GAME_OPTIONS = {\r\n  TICK: 400,\r\n  KEYS: {\r\n    RIGHT: \"ArrowRight\",\r\n    DOWN: \"ArrowDown\",\r\n    LEFT: \"ArrowLeft\",\r\n    ROTATE: \"ArrowUp\",\r\n  },\r\n};\r\n\r\nclass GameHandler {\r\n  private clock: NodeJS.Timer;\r\n\r\n  private ctx: CanvasRenderingContext2D;\r\n  private canvasWidth: number;\r\n  private canvasHeight: number;\r\n\r\n  private board = new Board();\r\n  private keyHandler: KeyHandler;\r\n\r\n  private gameStatus: GameStatus = GameStatus.NOT_PLAYING;\r\n\r\n  constructor(private canvas: HTMLCanvasElement) {\r\n    this.ctx = this.canvas.getContext(\"2d\");\r\n    this.canvasWidth = canvas.width;\r\n    this.canvasHeight = canvas.height;\r\n\r\n    this.keyHandler = new KeyHandler(this, GAME_OPTIONS.KEYS);\r\n\r\n    this.drawGame();\r\n  }\r\n\r\n  /**\r\n   * Draw polygon on the block\r\n   * @param coordinates\r\n   * @param color\r\n   */\r\n  drawPolygon(coordinates: { x: number; y: number }[], color: string) {\r\n    this.ctx.fillStyle = color;\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(coordinates[0].x, coordinates[0].y);\r\n    for (let i = 1; i < coordinates.length; ++i) {\r\n      this.ctx.lineTo(coordinates[i].x, coordinates[i].y);\r\n    }\r\n    this.ctx.closePath();\r\n    this.ctx.fill();\r\n  }\r\n\r\n  /**\r\n   * Draw border for the grid\r\n   * @param x\r\n   * @param y\r\n   */\r\n  drawBorder(x: number, y: number) {\r\n    const blockSizeWidth = this.canvasWidth / 2 / this.board.getWidth();\r\n    const blockSizeHeight = this.canvasHeight / this.board.getHeight();\r\n\r\n    this.ctx.beginPath();\r\n    this.ctx.strokeStyle = \"#ffffff10\";\r\n    this.ctx.rect(\r\n      x * blockSizeWidth,\r\n      y * blockSizeHeight,\r\n      blockSizeWidth,\r\n      blockSizeHeight\r\n    );\r\n    this.ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Draw one block for a tetris shape\r\n   * @param x\r\n   * @param y\r\n   * @param color\r\n   * @param suppX\r\n   * @param suppY\r\n   */\r\n  drawRect(x: number, y: number, color: string, suppX = 0, suppY = 0) {\r\n    const blockSizeWidth = this.canvasWidth / 2 / this.board.getWidth();\r\n    const blockSizeHeight = this.canvasHeight / this.board.getHeight();\r\n\r\n    const fx = x * blockSizeWidth + suppX;\r\n    const fy = y * blockSizeHeight + suppY;\r\n\r\n    this.ctx.fillStyle = color;\r\n    this.ctx.fillRect(fx, fy, blockSizeWidth, blockSizeHeight);\r\n\r\n    /* Fill polygons for best effect */\r\n    const coordinatesSupp = [\r\n      { x: fx, y: fy },\r\n      { x: fx + blockSizeWidth, y: fy },\r\n      {\r\n        x: fx + blockSizeWidth - blockSizeHeight / 4,\r\n        y: fy + blockSizeHeight / 4,\r\n      },\r\n      { x: fx + blockSizeHeight / 4, y: fy + blockSizeHeight / 4 },\r\n    ];\r\n    const coordinatesInf = [\r\n      { x: fx, y: fy + blockSizeHeight },\r\n      { x: fx + blockSizeWidth, y: fy + blockSizeHeight },\r\n      {\r\n        x: fx + blockSizeWidth - blockSizeHeight / 4,\r\n        y: fy + blockSizeHeight - blockSizeHeight / 4,\r\n      },\r\n      {\r\n        x: fx + blockSizeHeight / 4,\r\n        y: fy + blockSizeHeight - blockSizeHeight / 4,\r\n      },\r\n    ];\r\n    const coordinatesLeft = [\r\n      { x: fx, y: fy },\r\n      { x: fx + blockSizeWidth / 4, y: fy + blockSizeWidth / 4 },\r\n      {\r\n        x: fx + blockSizeWidth / 4,\r\n        y: fy + blockSizeHeight - blockSizeWidth / 4,\r\n      },\r\n      { x: fx, y: fy + blockSizeHeight },\r\n    ];\r\n    const coordinatesRight = [\r\n      { x: fx + blockSizeWidth, y: fy },\r\n      {\r\n        x: fx + blockSizeWidth - blockSizeWidth / 4,\r\n        y: fy + blockSizeWidth / 4,\r\n      },\r\n      {\r\n        x: fx + blockSizeWidth - blockSizeWidth / 4,\r\n        y: fy + blockSizeHeight - blockSizeWidth / 4,\r\n      },\r\n      { x: fx + blockSizeWidth, y: fy + blockSizeHeight },\r\n    ];\r\n    this.drawPolygon(coordinatesSupp, \"#ffffff80\");\r\n    this.drawPolygon(coordinatesInf, \"#00000080\");\r\n    this.drawPolygon(coordinatesLeft, \"#00000050\");\r\n    this.drawPolygon(coordinatesRight, \"#00000050\");\r\n  }\r\n\r\n  /**\r\n   * Draw all the game and informations\r\n   */\r\n  drawGame() {\r\n    const darkColor = \"#212129\";\r\n\r\n    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\r\n\r\n    this.ctx.fillStyle = darkColor;\r\n    this.ctx.fillRect(0, 0, this.canvasWidth / 2, this.canvasHeight);\r\n\r\n    const boardMatrix = this.board.getBoard();\r\n\r\n    /* Drawing main board */\r\n    for (let i = 0; i < boardMatrix.length; ++i) {\r\n      for (let j = 0; j < boardMatrix[i].length; ++j) {\r\n        const isBorderGrid = boardMatrix[i][j] === 0;\r\n\r\n        if (isBorderGrid) {\r\n          this.drawBorder(j, i);\r\n          continue;\r\n        }\r\n        //We set -1 because 0 was reserved for empty\r\n        const color = colors[boardMatrix[i][j] - 1];\r\n        this.drawRect(j, i, color);\r\n      }\r\n    }\r\n\r\n    const textX = this.canvasWidth / 2 + 10;\r\n\r\n    /* Score */\r\n    this.ctx.fillStyle = darkColor;\r\n    this.ctx.font = \"20px Arial, sans-serif\";\r\n    this.ctx.fillText(\"Score: \" + this.board.getScore(), textX, 35);\r\n\r\n    /* Game status */\r\n    this.ctx.fillText(\"Game status:\", textX, 65);\r\n    this.ctx.fillText(\"> \" + this.gameStatus, textX, 85);\r\n\r\n    /* Next Shape */\r\n    this.ctx.fillText(\"Next Shape:\", textX, 115);\r\n    const nextShape = this.board.getNextShape().getShape();\r\n    for (let i = 0; i < nextShape.length; ++i) {\r\n      for (let j = 0; j < nextShape[i].length; ++j) {\r\n        const dontNeedDraw = nextShape[i][j] === 0;\r\n\r\n        if (dontNeedDraw) continue;\r\n\r\n        //We set -1 because 0 was reserved for empty\r\n        const color = colors[nextShape[i][j] - 1];\r\n        this.drawRect(j, i, color, textX, 125);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Method to call when we loose\r\n   */\r\n  loose() {\r\n    this.gameStatus = GameStatus.LOOSE;\r\n    this.drawGame();\r\n    this.reset(false);\r\n  }\r\n\r\n  /**\r\n   * Start the game/clock\r\n   */\r\n  start() {\r\n    if (!this.clock) {\r\n      this.gameStatus = GameStatus.PLAYING;\r\n      this.clock = setInterval(() => {\r\n        this.board.update();\r\n        this.drawGame();\r\n        if (this.board.haveLoose()) this.loose();\r\n      }, GAME_OPTIONS.TICK);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop the game/clock\r\n   */\r\n  stop() {\r\n    clearInterval(this.clock);\r\n    this.gameStatus = GameStatus.NOT_PLAYING;\r\n    this.clock = null;\r\n    // this.drawGame();\r\n  }\r\n\r\n  /**\r\n   * Reset the game\r\n   * @param withDraw\r\n   */\r\n  reset(withDraw = true) {\r\n    this.stop();\r\n    this.board.reset();\r\n    if (withDraw) this.drawGame();\r\n  }\r\n\r\n  /**\r\n   * Check if game is playing\r\n   * @returns\r\n   */\r\n  isRunning() {\r\n    return !!this.clock;\r\n  }\r\n\r\n  getBoard() {\r\n    return this.board;\r\n  }\r\n}\r\n\r\nexport default GameHandler;\r\n","import GameHandler from \"./core/GameHandler\";\r\n\r\nconst canvas = document.querySelector(\"canvas\");\r\nconst playBtn = document.querySelector(\"#play\");\r\nconst pauseBtn = document.querySelector(\"#pause\");\r\nconst resetBtn = document.querySelector(\"#reset\");\r\n\r\nconst game = new GameHandler(canvas);\r\n\r\nplayBtn.addEventListener(\"click\", () => game.start());\r\npauseBtn.addEventListener(\"click\", () => game.stop());\r\nresetBtn.addEventListener(\"click\", () => game.reset());\r\n\r\nexport default game;\r\n","import game from \"../game\";\r\nimport AI from \"./core/AI\";\r\n\r\nconst ai = new AI(game);\r\n\r\nconst fpsRange: HTMLInputElement = document.querySelector(\"#fps\");\r\nconst startBtn = document.querySelector(\"#start-ai\");\r\nconst stopBtn = document.querySelector(\"#stop-ai\");\r\n\r\nfpsRange.addEventListener(\"change\", () => ai.setFps(Number(fpsRange.value)));\r\nstartBtn.addEventListener(\"click\", () => ai.start());\r\nstopBtn.addEventListener(\"click\", () => ai.stop());\r\n\r\nexport default ai;\r\n","import GameHandler from \"../../game/core/GameHandler\";\r\n\r\nclass AI {\r\n  private fps = 10;\r\n  private clock: NodeJS.Timeout;\r\n\r\n  constructor(private gameHandler: GameHandler) {}\r\n\r\n  main() {\r\n    const boardClass = this.gameHandler.getBoard();\r\n    const actualShapeClass = boardClass.getActualShape();\r\n    const nextShapeClass = boardClass.getNextShape();\r\n\r\n    const board = boardClass.getBoard();\r\n    const actualShape = actualShapeClass.getShape();\r\n    const nextShape = nextShapeClass.getShape();\r\n    const position = actualShapeClass.getPosition();\r\n\r\n    const boardCopy = boardClass.copy();\r\n\r\n    for (let i = 0; i < board.length; ++i) {\r\n      const isLineEmpty = board[i].every((col) => col === 0);\r\n      if (isLineEmpty) continue;\r\n\r\n      for (let j = 0; j < board[i].length; ++j) {\r\n        //for each rotation\r\n        for (let r = 0; r < 3; ++r) {\r\n          //TODO\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Refreshing and game status handling */\r\n    if (boardClass.haveLoose()) {\r\n      this.stop();\r\n      this.gameHandler.loose();\r\n    } else {\r\n      this.gameHandler.drawGame();\r\n      this.clock = setTimeout(() => this.main(), 1000 / this.fps);\r\n    }\r\n  }\r\n\r\n  start() {\r\n    //we stop the gameHandler to ensure we can't use key and the game dont refresh each GAME TICK\r\n    this.gameHandler.stop();\r\n    this.main();\r\n  }\r\n\r\n  stop() {\r\n    if (this.clock) clearTimeout(this.clock);\r\n  }\r\n\r\n  setFps(fps: number) {\r\n    this.fps = fps;\r\n  }\r\n}\r\n\r\nexport default AI;\r\n"],"names":["colors","shapes","Shape","constructor","board","shape","position","this","downTick","x","Math","floor","getWidth","length","y","randomShape","rndShape","random","rotate","matrix","numRows","numCols","rotated","col","newRow","row","push","newY","newX","canRotateX","canRotateY","getHeight","structuredClone","getBoard","i","j","update","canGoLeft","undefined","canGoRiht","canGoDown","haveReachedBottom","_a","_b","_c","goDown","goRight","goLeft","getShape","getPosition","copy","Board","width","height","score","actualShape","nextShape","buildBoard","removeLastShapeDraw","backShape","displayShape","haveLoose","some","getScoreFromCompletedLine","completedLines","removeCompletedLines","every","splice","unshift","Array","fill","getScore","getActualShape","getNextShape","getBackShape","setActualShape","setNextShape","setBackShape","setBoard","setScore","reset","KeyHandler","gameHandler","keys","initKeyListener","document","addEventListener","event","isRunning","key","cmd","Object","entries","find","arr","toLocaleLowerCase","drawGame","loose","GameStatus","GAME_OPTIONS","RIGHT","DOWN","LEFT","ROTATE","canvas","querySelector","playBtn","pauseBtn","resetBtn","game","gameStatus","NOT_PLAYING","ctx","getContext","canvasWidth","canvasHeight","keyHandler","drawPolygon","coordinates","color","fillStyle","beginPath","moveTo","lineTo","closePath","drawBorder","blockSizeWidth","blockSizeHeight","strokeStyle","rect","stroke","drawRect","suppX","suppY","fx","fy","fillRect","coordinatesSupp","coordinatesInf","coordinatesLeft","coordinatesRight","darkColor","clearRect","boardMatrix","textX","font","fillText","LOOSE","start","clock","PLAYING","setInterval","stop","clearInterval","withDraw","ai","fps","main","boardClass","actualShapeClass","nextShapeClass","setTimeout","clearTimeout","setFps","fpsRange","startBtn","stopBtn","Number","value"],"mappings":"2FAAA,MAAMA,EAAS,CACb,UACA,UACA,UACA,UACA,UACA,UACA,WCLIC,EAAwB,CAC5B,CAAC,CAAC,EAAG,EAAG,EAAG,IACX,CACE,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAET,CACE,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAET,CACE,CAAC,EAAG,GACJ,CAAC,EAAG,IAEN,CACE,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAET,CACE,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAET,CACE,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,KCvBX,MAAMC,EASJ,WAAAC,CACUC,EACAC,EACAC,EAAqC,MAFrCC,KAAKH,MAALA,EACAG,KAAKF,MAALA,EACAE,KAAQD,SAARA,EALFC,KAAQC,SAAG,EAOZD,KAAKD,WACRC,KAAKD,SAAW,CACdG,EAAGC,KAAKC,MAAMJ,KAAKH,MAAMQ,WAAa,EAAIL,KAAKF,MAAM,GAAGQ,OAAS,GACjEC,GAAIP,KAAKF,MAAMQ,QAGpB,CAOD,kBAAOE,CAAYX,GACjB,MAAMY,EAAWf,EAAOS,KAAKC,MAAMD,KAAKO,SAAWhB,EAAOY,SAC1D,OAAO,IAAIX,EAAME,EAAOY,EACzB,CAMD,MAAAE,GACE,MAAMC,EAASZ,KAAKF,MAEde,EAAUD,EAAON,OACjBQ,EAAUF,EAAO,GAAGN,OACpBS,EAAsB,GAE5B,IAAK,IAAIC,EAAM,EAAGA,EAAMF,EAASE,IAAO,CACtC,MAAMC,EAAmB,GACzB,IAAK,IAAIC,EAAML,EAAU,EAAGK,GAAO,EAAGA,IACpCD,EAAOE,KAAKP,EAAOM,GAAKF,IAE1BD,EAAQI,KAAKF,EACd,CAED,MAAMG,EACJpB,KAAKD,SAASQ,EACdJ,KAAKC,MAAMJ,KAAKF,MAAMQ,OAAS,GAC/BH,KAAKC,MAAMW,EAAQT,OAAS,GACxBe,EACJrB,KAAKD,SAASG,EACdC,KAAKC,MAAMJ,KAAKF,MAAM,GAAGQ,OAAS,GAClCH,KAAKC,MAAMW,EAAQ,GAAGT,OAAS,GAE3BgB,EACJD,EAAON,EAAQ,GAAGT,QAAUN,KAAKH,MAAMQ,YAAcgB,GAAQ,EACzDE,EAAaH,EAAOL,EAAQT,QAAUN,KAAKH,MAAM2B,YAEvD,GAAIF,GAAcC,EAAY,CAG5B,MAAM1B,EAAQ4B,gBAAgBzB,KAAKH,MAAM6B,YAGzC,IAAK,IAAIC,EAAI,EAAGA,EAAI3B,KAAKF,MAAMQ,SAAUqB,EACvC,IAAK,IAAIC,EAAI,EAAGA,EAAI5B,KAAKF,MAAM6B,GAAGrB,SAAUsB,EACtC5B,KAAKD,SAASQ,EAAIoB,GAAK,IACzB9B,EAAM8B,EAAI3B,KAAKD,SAASQ,GAAGqB,EAAI5B,KAAKD,SAASG,GAAK,GAKxD,IAAK,IAAIyB,EAAI,EAAGA,EAAIZ,EAAQT,SAAUqB,EACpC,IAAK,IAAIC,EAAI,EAAGA,EAAIb,EAAQY,GAAGrB,SAAUsB,EACvC,GAAIR,EAAOO,GAAK,GAAmC,IAA9B9B,EAAM8B,EAAIP,GAAMQ,EAAIP,GAAa,OAI1DrB,KAAKD,SAASQ,EAAIa,EAClBpB,KAAKD,SAASG,EAAImB,EAClBrB,KAAKF,MAAQiB,CACd,CAEDf,KAAKH,MAAMgC,QAAO,EACnB,CAMD,SAAAC,SACE,MAAMhC,EAAQE,KAAKF,MACbC,EAAWC,KAAKD,SAChBF,EAAQG,KAAKH,MAAM6B,WAEzB,IAAK,IAAIC,EAAI,EAAGA,EAAI7B,EAAMQ,SAAUqB,EAClC,IAAK,IAAIC,EAAI,EAAGA,EAAI9B,EAAM6B,GAAGrB,SAAUsB,EAAG,CAOxC,GALE7B,EAASQ,EAAIoB,GAAK,IACG,IAApB7B,EAAM6B,GAAGC,EAAI,SAAgCG,IAApBjC,EAAM6B,GAAGC,EAAI,KACS,eAAhD/B,EAAM8B,EAAI5B,EAASQ,yBAAKqB,EAAI7B,EAASG,EAAI,KAC1B,IAAfH,EAASG,GAE+B,IAAhBJ,EAAM6B,GAAGC,GAAU,OAAO,CACrD,CAGH,OAAO,CACR,CAMD,SAAAI,SACE,MAAMlC,EAAQE,KAAKF,MACbC,EAAWC,KAAKD,SAChBF,EAAQG,KAAKH,MAAM6B,WAEzB,IAAK,IAAIC,EAAI,EAAGA,EAAI7B,EAAMQ,SAAUqB,EAClC,IAAK,IAAIC,EAAI,EAAGA,EAAI9B,EAAM6B,GAAGrB,SAAUsB,EAAG,CAOxC,GALE7B,EAASQ,EAAIoB,GAAK,IACG,IAApB7B,EAAM6B,GAAGC,EAAI,SAAgCG,IAApBjC,EAAM6B,GAAGC,EAAI,KACS,eAAhD/B,EAAM8B,EAAI5B,EAASQ,yBAAKqB,EAAI7B,EAASG,EAAI,KACzCH,EAASG,IAAMF,KAAKH,MAAMQ,WAAaP,EAAM,GAAGQ,QAEP,IAAhBR,EAAM6B,GAAGC,GAAU,OAAO,CACtD,CAGH,OAAO,CACR,CAMD,SAAAK,aACE,GAAIjC,KAAKkC,oBAEP,QADElC,KAAKC,SACAD,KAAKC,UAAY,EAG1B,MAAMH,EAAQE,KAAKF,MACbC,EAAWC,KAAKD,SAChBF,EAAQG,KAAKH,MAAM6B,WAEzB,IAAK,IAAIC,EAAI,EAAGA,EAAI7B,EAAMQ,SAAUqB,EAClC,IAAK,IAAIC,EAAI,EAAGA,EAAI9B,EAAM6B,GAAGrB,SAAUsB,EAAG,CAMxC,GAJE7B,EAASQ,EAAIoB,EAAI,GAAK,IACC,KAAV,QAAZQ,EAAArC,EAAM6B,EAAI,UAAE,IAAAQ,OAAA,EAAAA,EAAGP,UAAkCG,KAAV,QAAZK,EAAAtC,EAAM6B,EAAI,UAAE,IAAAS,OAAA,EAAAA,EAAGR,MACK,KAApB,QAA5BS,EAAAxC,EAAM8B,EAAI5B,EAASQ,EAAI,UAAK,IAAA8B,OAAA,EAAAA,EAAAT,EAAI7B,EAASG,KAED,IAAhBJ,EAAM6B,GAAGC,GAEjC,QADE5B,KAAKC,SACAD,KAAKC,UAAY,CAE3B,CAKH,OAFAD,KAAKC,SAAW,GAET,CACR,CAKD,MAAAqC,GAEItC,KAAKD,SAASQ,IAAMP,KAAKH,MAAM2B,YAAcxB,KAAKF,MAAMQ,QACtC,IAAlBN,KAAKC,YAEHD,KAAKD,SAASQ,EAClBP,KAAKH,MAAMgC,QAAO,EACnB,CAMD,OAAAU,GACOvC,KAAKgC,cAENhC,KAAKD,SAASG,IAAMF,KAAKH,MAAMQ,WAAaL,KAAKF,MAAM,GAAGQ,UAC1DN,KAAKD,SAASG,EAClBF,KAAKH,MAAMgC,QAAO,GACnB,CAMD,MAAAW,GACOxC,KAAK8B,cAEc,IAApB9B,KAAKD,SAASG,GAASF,KAAKD,SAASG,IACzCF,KAAKH,MAAMgC,QAAO,GACnB,CAMD,iBAAAK,GACE,OAAOlC,KAAKD,SAASQ,IAAMP,KAAKH,MAAM2B,YAAcxB,KAAKF,MAAMQ,MAChE,CAED,QAAAmC,GACE,OAAOzC,KAAKF,KACb,CAED,WAAA4C,GACE,OAAO1C,KAAKD,QACb,CAMD,IAAA4C,GACE,OAAO,IAAIhD,EAAMK,KAAKH,MAAOG,KAAKF,MAAO2B,gBAAgBzB,KAAKD,UAC/D,ECvOH,MAAM6C,EASJ,WAAAhD,CAAoBiD,EAAQ,GAAYC,EAAS,IAA7B9C,KAAK6C,MAALA,EAAoB7C,KAAM8C,OAANA,EARhC9C,KAAKH,MAAe,GAEpBG,KAAK+C,MAAG,EAER/C,KAAAgD,YAAcrD,EAAMa,YAAYR,MAChCA,KAAAiD,UAAYtD,EAAMa,YAAYR,MAIpCA,KAAKkD,YACN,CAKO,UAAAA,GACN,IAAK,IAAIvB,EAAI,EAAGA,EAAI3B,KAAK6C,MAAQ7C,KAAK8C,SAAUnB,EAC1CA,EAAI3B,KAAK6C,OAAU,GAAG7C,KAAKH,MAAMsB,KAAK,IAC1CnB,KAAKH,MAAMG,KAAKH,MAAMS,OAAS,GAAGa,KAAK,EAE1C,CAMD,mBAAAgC,GACE,IAAKnD,KAAKoD,UAAW,OAErB,MAAMtD,EAAQE,KAAKoD,UAAUX,WACvB1C,EAAWC,KAAKoD,UAAUV,cAEhC,IAAK,IAAIf,EAAI,EAAGA,EAAI7B,EAAMQ,SAAUqB,EAClC,IAAK,IAAIC,EAAI,EAAGA,EAAI9B,EAAM6B,GAAGrB,SAAUsB,EACjC7B,EAASQ,EAAIoB,EAAI,GACD,IAAhB7B,EAAM6B,GAAGC,KAAU5B,KAAKH,MAAM8B,EAAI5B,EAASQ,GAAGqB,EAAI7B,EAASG,GAAK,EAGzE,CAKD,YAAAmD,GACE,MAAMvD,EAAQE,KAAKgD,YAAYP,WACzB1C,EAAWC,KAAKgD,YAAYN,cAElC,IAAK,IAAIf,EAAI,EAAGA,EAAI7B,EAAMQ,SAAUqB,EAClC,IAAK,IAAIC,EAAI,EAAGA,EAAI9B,EAAM6B,GAAGrB,SAAUsB,EACjC7B,EAASQ,EAAIoB,EAAI,GACD,IAAhB7B,EAAM6B,GAAGC,KACX5B,KAAKH,MAAM8B,EAAI5B,EAASQ,GAAGqB,EAAI7B,EAASG,GAAKJ,EAAM6B,GAAGC,GAG7D,CAMD,SAAA0B,GAEE,OADgBtD,KAAKH,MAAM,GACZ0D,MAAMvC,GAAgB,IAARA,MAAehB,KAAKgD,YAAYf,WAC9D,CAOD,yBAAAuB,CAA0BC,GACxB,OAAQA,GACN,KAAK,EACH,OAAO,EACT,KAAK,EACH,OAAO,GACT,KAAK,EACH,OAAO,IACT,KAAK,EACH,OAAO,IACT,QACE,OAAO,KAEZ,CAKD,oBAAAC,GACE,IAAID,EAAiB,EAErB,IAAK,IAAI9B,EAAI,EAAGA,EAAI3B,KAAKH,MAAMS,SAAUqB,EAAG,CAC7B3B,KAAKH,MAAM8B,GAEGgC,OAAO3C,GAAgB,IAARA,QAIxCyC,EACFzD,KAAKH,MAAM+D,OAAOjC,EAAG,GACrB3B,KAAKH,MAAMgE,QAAQC,MAAM9D,KAAK6C,OAAOkB,KAAK,IAC3C,CAED/D,KAAK+C,OAAS/C,KAAKwD,0BAA0BC,EAC9C,CAMD,MAAA5B,CAAOS,GAAS,GACdtC,KAAKmD,sBAEAnD,KAAKgD,YAAYf,cACpBjC,KAAK+C,OAAS/C,KAAKgD,YAAYP,WAAWnC,OAAS,EACnDN,KAAKqD,eACLrD,KAAK0D,uBACL1D,KAAKgD,YAAchD,KAAKiD,UACxBjD,KAAKiD,UAAYtD,EAAMa,YAAYR,OAGrCA,KAAKoD,UAAYpD,KAAKgD,YAAYL,OAE9BL,GAAQtC,KAAKgD,YAAYV,SAE7BtC,KAAKqD,cACN,CAED,QAAAW,GACE,OAAOhE,KAAK+C,KACb,CAED,QAAArB,GACE,OAAO1B,KAAKH,KACb,CAED,QAAAQ,GACE,OAAOL,KAAK6C,KACb,CAED,SAAArB,GACE,OAAOxB,KAAK8C,MACb,CAED,cAAAmB,GACE,OAAOjE,KAAKgD,WACb,CAED,YAAAkB,GACE,OAAOlE,KAAKiD,SACb,CAED,YAAAkB,GACE,OAAOnE,KAAKoD,SACb,CAED,cAAAgB,CAAetE,GACbE,KAAKgD,YAAclD,CACpB,CAED,YAAAuE,CAAavE,GACXE,KAAKiD,UAAYnD,CAClB,CAED,YAAAwE,CAAaxE,GACXE,KAAKoD,UAAYtD,CAClB,CAED,QAAAyE,CAAS1E,GACPG,KAAKH,MAAQA,CACd,CAED,QAAA2E,CAASzB,GACP/C,KAAK+C,MAAQA,CACd,CAKD,KAAA0B,GACEzE,KAAKH,MAAQ,GAEbG,KAAKgD,YAAcrD,EAAMa,YAAYR,MACrCA,KAAKiD,UAAYtD,EAAMa,YAAYR,MACnCA,KAAKoD,UAAY,KAEjBpD,KAAK+C,MAAQ,EAEb/C,KAAKkD,YACN,CAMD,IAAAP,GACE,MAAMA,EAAO,IAAIC,EAAM5C,KAAK6C,MAAO7C,KAAK8C,QAMxC,OALAH,EAAKyB,eAAepE,KAAKgD,YAAYL,QACrCA,EAAK0B,aAAarE,KAAKiD,UAAUN,QACjCA,EAAK2B,aAAatE,KAAKoD,UAAUT,QACjCA,EAAK4B,SAAS9C,gBAAgBzB,KAAKH,QACnC8C,EAAK6B,SAASxE,KAAK+C,OACZJ,CACR,ECrMH,MAAM+B,EACJ,WAAA9E,CAAoB+E,EAAkCC,GAAlC5E,KAAW2E,YAAXA,EAAkC3E,KAAI4E,KAAJA,EACpD5E,KAAK6E,iBACN,CAKD,eAAAA,GACE,MAAMhF,EAAQG,KAAK2E,YAAYjD,WAE/BoD,SAASC,iBAAiB,WAAYC,IACpC,IAAKhF,KAAK2E,YAAYM,YAAa,OAEnC,MAAMC,EAAMF,EAAME,IACZC,EAAMC,OAAOC,QAAQrF,KAAK4E,MAAMU,MACnCC,GAAQA,EAAI,GAAGC,sBAAwBN,EAAIM,sBAG9C,GAAIL,EAAK,CACP,MAAMrF,EAAQD,EAAMoE,iBAEpB,OAAQkB,EAAI,IACV,IAAK,QACHrF,EAAMyC,UACN,MACF,IAAK,OACHzC,EAAM0C,SACN,MACF,IAAK,OACH1C,EAAMwC,SACN,MACF,IAAK,SACHxC,EAAMa,SAIVX,KAAK2E,YAAYc,WACb5F,EAAMyD,aAAatD,KAAK2E,YAAYe,OACzC,IAEJ,EC9CH,IAAKC,GAAL,SAAKA,GACHA,EAAA,MAAA,YACAA,EAAA,YAAA,cACAA,EAAA,QAAA,SACD,CAJD,CAAKA,IAAAA,EAIJ,CAAA,IAED,MAAMC,EACE,IADFA,EAEE,CACJC,MAAO,aACPC,KAAM,YACNC,KAAM,YACNC,OAAQ,WCdZ,MAAMC,EAASnB,SAASoB,cAAc,UAChCC,EAAUrB,SAASoB,cAAc,SACjCE,EAAWtB,SAASoB,cAAc,UAClCG,EAAWvB,SAASoB,cAAc,UAElCI,EAAO,IDab,MAYE,WAAA1G,CAAoBqG,GAAAjG,KAAMiG,OAANA,EALZjG,KAAAH,MAAQ,IAAI+C,EAGZ5C,KAAAuG,WAAyBZ,EAAWa,YAG1CxG,KAAKyG,IAAMzG,KAAKiG,OAAOS,WAAW,MAClC1G,KAAK2G,YAAcV,EAAOpD,MAC1B7C,KAAK4G,aAAeX,EAAOnD,OAE3B9C,KAAK6G,WAAa,IAAInC,EAAW1E,KAAM4F,GAEvC5F,KAAKyF,UACN,CAOD,WAAAqB,CAAYC,EAAyCC,GACnDhH,KAAKyG,IAAIQ,UAAYD,EACrBhH,KAAKyG,IAAIS,YACTlH,KAAKyG,IAAIU,OAAOJ,EAAY,GAAG7G,EAAG6G,EAAY,GAAGxG,GACjD,IAAK,IAAIoB,EAAI,EAAGA,EAAIoF,EAAYzG,SAAUqB,EACxC3B,KAAKyG,IAAIW,OAAOL,EAAYpF,GAAGzB,EAAG6G,EAAYpF,GAAGpB,GAEnDP,KAAKyG,IAAIY,YACTrH,KAAKyG,IAAI1C,MACV,CAOD,UAAAuD,CAAWpH,EAAWK,GACpB,MAAMgH,EAAiBvH,KAAK2G,YAAc,EAAI3G,KAAKH,MAAMQ,WACnDmH,EAAkBxH,KAAK4G,aAAe5G,KAAKH,MAAM2B,YAEvDxB,KAAKyG,IAAIS,YACTlH,KAAKyG,IAAIgB,YAAc,YACvBzH,KAAKyG,IAAIiB,KACPxH,EAAIqH,EACJhH,EAAIiH,EACJD,EACAC,GAEFxH,KAAKyG,IAAIkB,QACV,CAUD,QAAAC,CAAS1H,EAAWK,EAAWyG,EAAea,EAAQ,EAAGC,EAAQ,GAC/D,MAAMP,EAAiBvH,KAAK2G,YAAc,EAAI3G,KAAKH,MAAMQ,WACnDmH,EAAkBxH,KAAK4G,aAAe5G,KAAKH,MAAM2B,YAEjDuG,EAAK7H,EAAIqH,EAAiBM,EAC1BG,EAAKzH,EAAIiH,EAAkBM,EAEjC9H,KAAKyG,IAAIQ,UAAYD,EACrBhH,KAAKyG,IAAIwB,SAASF,EAAIC,EAAIT,EAAgBC,GAG1C,MAAMU,EAAkB,CACtB,CAAEhI,EAAG6H,EAAIxH,EAAGyH,GACZ,CAAE9H,EAAG6H,EAAKR,EAAgBhH,EAAGyH,GAC7B,CACE9H,EAAG6H,EAAKR,EAAiBC,EAAkB,EAC3CjH,EAAGyH,EAAKR,EAAkB,GAE5B,CAAEtH,EAAG6H,EAAKP,EAAkB,EAAGjH,EAAGyH,EAAKR,EAAkB,IAErDW,EAAiB,CACrB,CAAEjI,EAAG6H,EAAIxH,EAAGyH,EAAKR,GACjB,CAAEtH,EAAG6H,EAAKR,EAAgBhH,EAAGyH,EAAKR,GAClC,CACEtH,EAAG6H,EAAKR,EAAiBC,EAAkB,EAC3CjH,EAAGyH,EAAKR,EAAkBA,EAAkB,GAE9C,CACEtH,EAAG6H,EAAKP,EAAkB,EAC1BjH,EAAGyH,EAAKR,EAAkBA,EAAkB,IAG1CY,EAAkB,CACtB,CAAElI,EAAG6H,EAAIxH,EAAGyH,GACZ,CAAE9H,EAAG6H,EAAKR,EAAiB,EAAGhH,EAAGyH,EAAKT,EAAiB,GACvD,CACErH,EAAG6H,EAAKR,EAAiB,EACzBhH,EAAGyH,EAAKR,EAAkBD,EAAiB,GAE7C,CAAErH,EAAG6H,EAAIxH,EAAGyH,EAAKR,IAEba,EAAmB,CACvB,CAAEnI,EAAG6H,EAAKR,EAAgBhH,EAAGyH,GAC7B,CACE9H,EAAG6H,EAAKR,EAAiBA,EAAiB,EAC1ChH,EAAGyH,EAAKT,EAAiB,GAE3B,CACErH,EAAG6H,EAAKR,EAAiBA,EAAiB,EAC1ChH,EAAGyH,EAAKR,EAAkBD,EAAiB,GAE7C,CAAErH,EAAG6H,EAAKR,EAAgBhH,EAAGyH,EAAKR,IAEpCxH,KAAK8G,YAAYoB,EAAiB,aAClClI,KAAK8G,YAAYqB,EAAgB,aACjCnI,KAAK8G,YAAYsB,EAAiB,aAClCpI,KAAK8G,YAAYuB,EAAkB,YACpC,CAKD,QAAA5C,GACE,MAAM6C,EAAY,UAElBtI,KAAKyG,IAAI8B,UAAU,EAAG,EAAGvI,KAAK2G,YAAa3G,KAAK4G,cAEhD5G,KAAKyG,IAAIQ,UAAYqB,EACrBtI,KAAKyG,IAAIwB,SAAS,EAAG,EAAGjI,KAAK2G,YAAc,EAAG3G,KAAK4G,cAEnD,MAAM4B,EAAcxI,KAAKH,MAAM6B,WAG/B,IAAK,IAAIC,EAAI,EAAGA,EAAI6G,EAAYlI,SAAUqB,EACxC,IAAK,IAAIC,EAAI,EAAGA,EAAI4G,EAAY7G,GAAGrB,SAAUsB,EAAG,CAG9C,GAF2C,IAAtB4G,EAAY7G,GAAGC,GAElB,CAChB5B,KAAKsH,WAAW1F,EAAGD,GACnB,QACD,CAED,MAAMqF,EAAQvH,EAAO+I,EAAY7G,GAAGC,GAAK,GACzC5B,KAAK4H,SAAShG,EAAGD,EAAGqF,EACrB,CAGH,MAAMyB,EAAQzI,KAAK2G,YAAc,EAAI,GAGrC3G,KAAKyG,IAAIQ,UAAYqB,EACrBtI,KAAKyG,IAAIiC,KAAO,yBAChB1I,KAAKyG,IAAIkC,SAAS,UAAY3I,KAAKH,MAAMmE,WAAYyE,EAAO,IAG5DzI,KAAKyG,IAAIkC,SAAS,eAAgBF,EAAO,IACzCzI,KAAKyG,IAAIkC,SAAS,KAAO3I,KAAKuG,WAAYkC,EAAO,IAGjDzI,KAAKyG,IAAIkC,SAAS,cAAeF,EAAO,KACxC,MAAMxF,EAAYjD,KAAKH,MAAMqE,eAAezB,WAC5C,IAAK,IAAId,EAAI,EAAGA,EAAIsB,EAAU3C,SAAUqB,EACtC,IAAK,IAAIC,EAAI,EAAGA,EAAIqB,EAAUtB,GAAGrB,SAAUsB,EAAG,CAG5C,GAFyC,IAApBqB,EAAUtB,GAAGC,GAEhB,SAGlB,MAAMoF,EAAQvH,EAAOwD,EAAUtB,GAAGC,GAAK,GACvC5B,KAAK4H,SAAShG,EAAGD,EAAGqF,EAAOyB,EAAO,IACnC,CAEJ,CAKD,KAAA/C,GACE1F,KAAKuG,WAAaZ,EAAWiD,MAC7B5I,KAAKyF,WACLzF,KAAKyE,OAAM,EACZ,CAKD,KAAAoE,GACO7I,KAAK8I,QACR9I,KAAKuG,WAAaZ,EAAWoD,QAC7B/I,KAAK8I,MAAQE,aAAY,KACvBhJ,KAAKH,MAAMgC,SACX7B,KAAKyF,WACDzF,KAAKH,MAAMyD,aAAatD,KAAK0F,OAAO,GACvCE,GAEN,CAKD,IAAAqD,GACEC,cAAclJ,KAAK8I,OACnB9I,KAAKuG,WAAaZ,EAAWa,YAC7BxG,KAAK8I,MAAQ,IAEd,CAMD,KAAArE,CAAM0E,GAAW,GACfnJ,KAAKiJ,OACLjJ,KAAKH,MAAM4E,QACP0E,GAAUnJ,KAAKyF,UACpB,CAMD,SAAAR,GACE,QAASjF,KAAK8I,KACf,CAED,QAAApH,GACE,OAAO1B,KAAKH,KACb,GCtP0BoG,GAE7BE,EAAQpB,iBAAiB,SAAS,IAAMuB,EAAKuC,UAC7CzC,EAASrB,iBAAiB,SAAS,IAAMuB,EAAK2C,SAC9C5C,EAAStB,iBAAiB,SAAS,IAAMuB,EAAK7B,UCR9C,MAAM2E,EAAK,ICDX,MAIE,WAAAxJ,CAAoB+E,GAAA3E,KAAW2E,YAAXA,EAHZ3E,KAAGqJ,IAAG,EAGkC,CAEhD,IAAAC,GACE,MAAMC,EAAavJ,KAAK2E,YAAYjD,WAC9B8H,EAAmBD,EAAWtF,iBAC9BwF,EAAiBF,EAAWrF,eAE5BrE,EAAQ0J,EAAW7H,WACL8H,EAAiB/G,WACnBgH,EAAehH,WAChB+G,EAAiB9G,cAEhB6G,EAAW5G,OAE7B,IAAK,IAAIhB,EAAI,EAAGA,EAAI9B,EAAMS,SAAUqB,EAAG,CAErC,IADoB9B,EAAM8B,GAAGgC,OAAO3C,GAAgB,IAARA,IAG5C,IAAK,IAAIY,EAAI,EAAGA,EAAI/B,EAAM8B,GAAGrB,SAAUsB,GAMxC,CAGG2H,EAAWjG,aACbtD,KAAKiJ,OACLjJ,KAAK2E,YAAYe,UAEjB1F,KAAK2E,YAAYc,WACjBzF,KAAK8I,MAAQY,YAAW,IAAM1J,KAAKsJ,QAAQ,IAAOtJ,KAAKqJ,KAE1D,CAED,KAAAR,GAEE7I,KAAK2E,YAAYsE,OACjBjJ,KAAKsJ,MACN,CAED,IAAAL,GACMjJ,KAAK8I,OAAOa,aAAa3J,KAAK8I,MACnC,CAED,MAAAc,CAAOP,GACLrJ,KAAKqJ,IAAMA,CACZ,GDnDe/C,GAEZuD,EAA6B/E,SAASoB,cAAc,QACpD4D,EAAWhF,SAASoB,cAAc,aAClC6D,EAAUjF,SAASoB,cAAc,YAEvC2D,EAAS9E,iBAAiB,UAAU,IAAMqE,EAAGQ,OAAOI,OAAOH,EAASI,UACpEH,EAAS/E,iBAAiB,SAAS,IAAMqE,EAAGP,UAC5CkB,EAAQhF,iBAAiB,SAAS,IAAMqE,EAAGH"}