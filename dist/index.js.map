{"version":3,"file":"index.js","sources":["../src/constants/colors.ts","../src/constants/shapes.ts","../src/core/Shape.ts","../src/core/Board.ts","../src/core/KeyHandler.ts","../src/core/GameHandler.ts","../src/index.ts"],"sourcesContent":["const colors = [\r\n  \"#00f0f0\",\r\n  \"#0000f5\",\r\n  \"#f0a000\",\r\n  \"#f0f000\",\r\n  \"#00f000\",\r\n  \"#a000f0\",\r\n  \"#f00000\",\r\n] as const;\r\n\r\nexport default colors;\r\n","type ShapeMatrix = number[][];\r\n\r\nconst shapes: ShapeMatrix[] = [\r\n  [[1, 1, 1, 1]],\r\n  [\r\n    [2, 0, 0],\r\n    [2, 2, 2],\r\n  ],\r\n  [\r\n    [0, 0, 3],\r\n    [3, 3, 3],\r\n  ],\r\n  [\r\n    [4, 4],\r\n    [4, 4],\r\n  ],\r\n  [\r\n    [0, 5, 5],\r\n    [5, 5, 0],\r\n  ],\r\n  [\r\n    [0, 6, 0],\r\n    [6, 6, 6],\r\n  ],\r\n  [\r\n    [7, 7, 0],\r\n    [0, 7, 7],\r\n  ],\r\n];\r\n\r\nexport default shapes;\r\n","import shapes from \"../constants/shapes\";\r\nimport Board from \"./Board\";\r\n\r\nclass Shape {\r\n  /**\r\n   * we want to be able to do a last action when the shape can't go down anymore\r\n   * 0 we can do anything\r\n   * 1 we can do anything except going down\r\n   * > 1 we can't do anything\r\n   */\r\n  private downTick = 0;\r\n\r\n  constructor(\r\n    private board: Board,\r\n    private shape: number[][],\r\n    private position: { x: number; y: number } = null\r\n  ) {\r\n    if (!this.position) {\r\n      this.position = {\r\n        x: Math.floor(this.board.getWidth() / 2 - this.shape[0].length / 2),\r\n        y: -this.shape.length,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a random shape\r\n   * @param board\r\n   * @returns\r\n   */\r\n  static randomShape(board: Board) {\r\n    const rndShape = shapes[Math.floor(Math.random() * shapes.length)];\r\n    return new Shape(board, rndShape);\r\n  }\r\n\r\n  /**\r\n   * Rotate the shape in clockwise with 90 degrees\r\n   * @returns\r\n   */\r\n  rotate() {\r\n    let haveRotate = false;\r\n\r\n    const matrix = this.shape;\r\n\r\n    const numRows = matrix.length;\r\n    const numCols = matrix[0].length;\r\n    const rotated: number[][] = [];\r\n\r\n    for (let col = 0; col < numCols; col++) {\r\n      const newRow: number[] = [];\r\n      for (let row = numRows - 1; row >= 0; row--) {\r\n        newRow.push(matrix[row][col]);\r\n      }\r\n      rotated.push(newRow);\r\n    }\r\n\r\n    const newY =\r\n      this.position.y +\r\n      Math.floor(this.shape.length / 2) -\r\n      Math.floor(rotated.length / 2);\r\n    const newX =\r\n      this.position.x +\r\n      Math.floor(this.shape[0].length / 2) -\r\n      Math.floor(rotated[0].length / 2);\r\n\r\n    const canRotateX =\r\n      newX + rotated[0].length <= this.board.getWidth() && newX >= 0;\r\n    const canRotateY = newY + rotated.length <= this.board.getHeight();\r\n\r\n    if (canRotateX && canRotateY) {\r\n      //TODO (Optimisation): Make the rotation better without that much loop\r\n      //Run well so not that much a big priority\r\n      const board = structuredClone(this.board.getBoard());\r\n\r\n      //We simulate the removing of the original shape\r\n      for (let i = 0; i < this.shape.length; ++i) {\r\n        for (let j = 0; j < this.shape[i].length; ++j) {\r\n          if (this.position.y + i >= 0)\r\n            board[i + this.position.y][j + this.position.x] = 0;\r\n        }\r\n      }\r\n\r\n      //checking we dont make conflict with other shapes\r\n      for (let i = 0; i < rotated.length; ++i) {\r\n        for (let j = 0; j < rotated[i].length; ++j) {\r\n          if (newY + i >= 0 && board[i + newY][j + newX] !== 0)\r\n            return haveRotate;\r\n        }\r\n      }\r\n\r\n      haveRotate = true;\r\n\r\n      this.position.y = newY;\r\n      this.position.x = newX;\r\n      this.shape = rotated;\r\n    }\r\n\r\n    this.board.update(false);\r\n    return haveRotate;\r\n  }\r\n\r\n  /**\r\n   * Check if the shape can go on the left\r\n   * @returns\r\n   */\r\n  canGoLeft(checkY = true) {\r\n    const shape = this.shape;\r\n    const position = this.position;\r\n    const board = this.board.getBoard();\r\n\r\n    for (let i = 0; i < shape.length; ++i) {\r\n      for (let j = 0; j < shape[i].length; ++j) {\r\n        const isIntersectingLeft =\r\n          (!checkY || position.y + i >= 0) &&\r\n          (shape[i][j - 1] === 0 || shape[i][j - 1] === undefined) &&\r\n          board[i + position.y]?.[j + position.x - 1] !== 0;\r\n\r\n        if (isIntersectingLeft && shape[i][j] !== 0) return false;\r\n      }\r\n    }\r\n\r\n    // throw new Error(\"lol\");\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Check if the shape can go on the right\r\n   * @returns\r\n   */\r\n  canGoRiht(checkY = true) {\r\n    const shape = this.shape;\r\n    const position = this.position;\r\n    const board = this.board.getBoard();\r\n\r\n    for (let i = 0; i < shape.length; ++i) {\r\n      for (let j = 0; j < shape[i].length; ++j) {\r\n        const isIntersectingRight =\r\n          (!checkY || position.y + i >= 0) &&\r\n          (shape[i][j + 1] === 0 || shape[i][j + 1] === undefined) &&\r\n          board[i + position.y]?.[j + position.x + 1] !== 0;\r\n\r\n        if (isIntersectingRight && shape[i][j] !== 0) return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Check if the shape can go down\r\n   * @returns\r\n   */\r\n  canGoDown() {\r\n    if (this.haveReachedBottom()) {\r\n      ++this.downTick;\r\n      return this.downTick <= 1;\r\n    }\r\n\r\n    const shape = this.shape;\r\n    const position = this.position;\r\n    const board = this.board.getBoard();\r\n\r\n    for (let i = 0; i < shape.length; ++i) {\r\n      for (let j = 0; j < shape[i].length; ++j) {\r\n        const isIntersectingDown =\r\n          position.y + i + 1 >= 0 &&\r\n          (shape[i + 1]?.[j] === 0 || shape[i + 1]?.[j] === undefined) &&\r\n          board[i + position.y + 1]?.[j + position.x] !== 0;\r\n\r\n        if (isIntersectingDown && shape[i][j] !== 0) {\r\n          ++this.downTick;\r\n          return this.downTick <= 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.downTick = 0;\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Make the shape go down\r\n   */\r\n  goDown() {\r\n    if (\r\n      this.position.y !== this.board.getHeight() - this.shape.length &&\r\n      this.downTick === 0\r\n    )\r\n      ++this.position.y;\r\n    this.board.update(false);\r\n  }\r\n\r\n  /**\r\n   * Make the shape go on the right\r\n   * @returns\r\n   */\r\n  goRight() {\r\n    if (!this.canGoRiht()) return;\r\n\r\n    if (this.position.x !== this.board.getWidth() - this.shape[0].length)\r\n      ++this.position.x;\r\n    this.board.update(false);\r\n  }\r\n\r\n  /**\r\n   * Make the shape go on the left\r\n   * @returns\r\n   */\r\n  goLeft() {\r\n    if (!this.canGoLeft()) return;\r\n\r\n    if (this.position.x !== 0) this.position.x--;\r\n    this.board.update(false);\r\n  }\r\n\r\n  /**\r\n   * Check if we have reached bottom of the board and cant go down anymore\r\n   * @returns\r\n   */\r\n  haveReachedBottom() {\r\n    return this.position.y === this.board.getHeight() - this.shape.length;\r\n  }\r\n\r\n  getShape() {\r\n    return this.shape;\r\n  }\r\n\r\n  getPosition() {\r\n    return this.position;\r\n  }\r\n\r\n  /**\r\n   * Create a copy of the shape\r\n   * @returns\r\n   */\r\n  copy() {\r\n    return new Shape(this.board, this.shape, structuredClone(this.position));\r\n  }\r\n}\r\n\r\nexport default Shape;\r\n","import Shape from \"./Shape\";\r\n\r\nclass Board {\r\n  private board: number[][] = [];\r\n\r\n  private score = 0;\r\n\r\n  private actualShape = Shape.randomShape(this);\r\n  private nextShape = Shape.randomShape(this);\r\n  private backShape: Shape;\r\n\r\n  constructor(private width = 12, private height = 24) {\r\n    this.buildBoard();\r\n  }\r\n\r\n  /**\r\n   * Build the board\r\n   */\r\n  private buildBoard() {\r\n    for (let i = 0; i < this.width * this.height; ++i) {\r\n      if (i % this.width === 0) this.board.push([]);\r\n      this.board[this.board.length - 1].push(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove the last position of the actual shape from the board\r\n   * @returns\r\n   */\r\n  removeLastShapeDraw() {\r\n    if (!this.backShape) return;\r\n\r\n    const shape = this.backShape.getShape();\r\n    const position = this.backShape.getPosition();\r\n\r\n    for (let i = 0; i < shape.length; ++i) {\r\n      for (let j = 0; j < shape[i].length; ++j) {\r\n        if (position.y + i < 0) continue;\r\n        if (shape[i][j] !== 0) this.board[i + position.y][j + position.x] = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the actual shape to the board\r\n   */\r\n  displayShape() {\r\n    const shape = this.actualShape.getShape();\r\n    const position = this.actualShape.getPosition();\r\n\r\n    for (let i = 0; i < shape.length; ++i) {\r\n      for (let j = 0; j < shape[i].length; ++j) {\r\n        if (position.y + i < 0) continue;\r\n        if (shape[i][j] !== 0)\r\n          this.board[i + position.y][j + position.x] = shape[i][j];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the game is loose\r\n   * @returns\r\n   */\r\n  haveLoose() {\r\n    const topLine = this.board[0];\r\n    return topLine.some((col) => col !== 0) && !this.actualShape.canGoDown();\r\n  }\r\n\r\n  /**\r\n   * Get the score from the completed lines as the same moment\r\n   * @param completedLines\r\n   * @returns\r\n   */\r\n  getScoreFromCompletedLine(completedLines: number) {\r\n    switch (completedLines) {\r\n      case 0:\r\n        return 0;\r\n      case 1:\r\n        return 40;\r\n      case 2:\r\n        return 100;\r\n      case 3:\r\n        return 300;\r\n      default:\r\n        return 1200;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove completed lines and set the score based on it\r\n   */\r\n  removeCompletedLines() {\r\n    let completedLines = 0;\r\n\r\n    for (let i = 0; i < this.board.length; ++i) {\r\n      const line = this.board[i];\r\n\r\n      const lineCompleted = line.every((col) => col !== 0);\r\n\r\n      if (!lineCompleted) continue;\r\n\r\n      ++completedLines;\r\n      this.board.splice(i, 1);\r\n      this.board.unshift(Array(this.width).fill(0));\r\n    }\r\n\r\n    this.score += this.getScoreFromCompletedLine(completedLines);\r\n  }\r\n\r\n  /**\r\n   * Update the board (make shape go down, ...)\r\n   * @param goDown\r\n   */\r\n  update(goDown = true) {\r\n    this.removeLastShapeDraw();\r\n\r\n    if (!this.actualShape.canGoDown()) {\r\n      this.score += this.actualShape.getShape().length + 1; //We had the numbers of rows + 1 to the score\r\n      this.displayShape();\r\n      this.removeCompletedLines();\r\n      this.actualShape = this.nextShape;\r\n      this.nextShape = Shape.randomShape(this);\r\n    }\r\n\r\n    this.backShape = this.actualShape.copy();\r\n\r\n    if (goDown) this.actualShape.goDown();\r\n\r\n    this.displayShape();\r\n  }\r\n\r\n  getScore() {\r\n    return this.score;\r\n  }\r\n\r\n  getBoard() {\r\n    return this.board;\r\n  }\r\n\r\n  getWidth() {\r\n    return this.width;\r\n  }\r\n\r\n  getHeight() {\r\n    return this.height;\r\n  }\r\n\r\n  getActualShape() {\r\n    return this.actualShape;\r\n  }\r\n\r\n  getNextShape() {\r\n    return this.nextShape;\r\n  }\r\n\r\n  getBackShape() {\r\n    return this.backShape;\r\n  }\r\n\r\n  setActualShape(shape: Shape) {\r\n    this.actualShape = shape;\r\n  }\r\n\r\n  setNextShape(shape: Shape) {\r\n    this.nextShape = shape;\r\n  }\r\n\r\n  setBackShape(shape: Shape) {\r\n    this.backShape = shape;\r\n  }\r\n\r\n  setBoard(board: number[][]) {\r\n    this.board = board;\r\n  }\r\n\r\n  setScore(score: number) {\r\n    this.score = score;\r\n  }\r\n\r\n  /**\r\n   * Reset the board\r\n   */\r\n  reset() {\r\n    this.board = [];\r\n\r\n    this.actualShape = Shape.randomShape(this);\r\n    this.nextShape = Shape.randomShape(this);\r\n    this.backShape = null;\r\n\r\n    this.score = 0;\r\n\r\n    this.buildBoard();\r\n  }\r\n\r\n  /**\r\n   * Create a deep copy of the board\r\n   * @returns\r\n   */\r\n  copy() {\r\n    const copy = new Board(this.width, this.height);\r\n    copy.setActualShape(this.actualShape.copy());\r\n    copy.setNextShape(this.nextShape.copy());\r\n    copy.setBackShape(this.backShape.copy());\r\n    copy.setBoard(structuredClone(this.board));\r\n    copy.setScore(this.score);\r\n    return copy;\r\n  }\r\n}\r\n\r\nexport default Board;\r\n","import GameHandler from \"./GameHandler\";\r\n\r\ntype Keys = {\r\n  RIGHT: string;\r\n  DOWN: string;\r\n  LEFT: string;\r\n  ROTATE: string;\r\n};\r\n\r\nclass KeyHandler {\r\n  constructor(private gameHandler: GameHandler, private keys: Keys) {\r\n    this.initKeyListener();\r\n  }\r\n\r\n  /**\r\n   * Append key listener to the dom\r\n   */\r\n  initKeyListener() {\r\n    const board = this.gameHandler.getBoard();\r\n\r\n    document.addEventListener(\"keydown\", (event) => {\r\n      if (!this.gameHandler.isRunning()) return;\r\n\r\n      const key = event.key;\r\n      const cmd = Object.entries(this.keys).find(\r\n        (arr) => arr[1].toLocaleLowerCase() === key.toLocaleLowerCase()\r\n      );\r\n\r\n      if (cmd) {\r\n        const shape = board.getActualShape();\r\n\r\n        switch (cmd[0]) {\r\n          case \"RIGHT\":\r\n            shape.goRight();\r\n            break;\r\n          case \"LEFT\":\r\n            shape.goLeft();\r\n            break;\r\n          case \"DOWN\":\r\n            shape.goDown();\r\n            break;\r\n          case \"ROTATE\":\r\n            shape.rotate();\r\n            break;\r\n        }\r\n\r\n        this.gameHandler.drawGame();\r\n        if (board.haveLoose()) this.gameHandler.loose();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default KeyHandler;\r\n","import colors from \"../constants/colors\";\r\nimport Board from \"./Board\";\r\nimport KeyHandler from \"./KeyHandler\";\r\n\r\nenum GameStatus {\r\n  LOOSE = \"You loose\",\r\n  NOT_PLAYING = \"Not playing\",\r\n  PLAYING = \"Playing\",\r\n}\r\n\r\nconst GAME_OPTIONS = {\r\n  TICK: 400,\r\n  KEYS: {\r\n    RIGHT: \"ArrowRight\",\r\n    DOWN: \"ArrowDown\",\r\n    LEFT: \"ArrowLeft\",\r\n    ROTATE: \"ArrowUp\",\r\n  },\r\n};\r\n\r\nclass GameHandler {\r\n  private clock: NodeJS.Timer;\r\n\r\n  private ctx: CanvasRenderingContext2D;\r\n  private canvasWidth: number;\r\n  private canvasHeight: number;\r\n\r\n  private board = new Board();\r\n  private keyHandler: KeyHandler;\r\n\r\n  private gameStatus: GameStatus = GameStatus.NOT_PLAYING;\r\n\r\n  constructor(private canvas: HTMLCanvasElement) {\r\n    this.ctx = this.canvas.getContext(\"2d\");\r\n    this.canvasWidth = canvas.width;\r\n    this.canvasHeight = canvas.height;\r\n\r\n    this.keyHandler = new KeyHandler(this, GAME_OPTIONS.KEYS);\r\n\r\n    this.drawGame();\r\n  }\r\n\r\n  /**\r\n   * Draw polygon on the block\r\n   * @param coordinates\r\n   * @param color\r\n   */\r\n  drawPolygon(coordinates: { x: number; y: number }[], color: string) {\r\n    this.ctx.fillStyle = color;\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(coordinates[0].x, coordinates[0].y);\r\n    for (let i = 1; i < coordinates.length; ++i) {\r\n      this.ctx.lineTo(coordinates[i].x, coordinates[i].y);\r\n    }\r\n    this.ctx.closePath();\r\n    this.ctx.fill();\r\n  }\r\n\r\n  /**\r\n   * Draw border for the grid\r\n   * @param x\r\n   * @param y\r\n   */\r\n  drawBorder(x: number, y: number) {\r\n    const blockSizeWidth = this.canvasWidth / 2 / this.board.getWidth();\r\n    const blockSizeHeight = this.canvasHeight / this.board.getHeight();\r\n\r\n    this.ctx.beginPath();\r\n    this.ctx.strokeStyle = \"#ffffff10\";\r\n    this.ctx.rect(\r\n      x * blockSizeWidth,\r\n      y * blockSizeHeight,\r\n      blockSizeWidth,\r\n      blockSizeHeight\r\n    );\r\n    this.ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Draw one block for a tetris shape\r\n   * @param x\r\n   * @param y\r\n   * @param color\r\n   * @param suppX\r\n   * @param suppY\r\n   */\r\n  drawRect(x: number, y: number, color: string, suppX = 0, suppY = 0) {\r\n    const blockSizeWidth = this.canvasWidth / 2 / this.board.getWidth();\r\n    const blockSizeHeight = this.canvasHeight / this.board.getHeight();\r\n\r\n    const fx = x * blockSizeWidth + suppX;\r\n    const fy = y * blockSizeHeight + suppY;\r\n\r\n    this.ctx.fillStyle = color;\r\n    this.ctx.fillRect(fx, fy, blockSizeWidth, blockSizeHeight);\r\n\r\n    /* Fill polygons for best effect */\r\n    const coordinatesSupp = [\r\n      { x: fx, y: fy },\r\n      { x: fx + blockSizeWidth, y: fy },\r\n      {\r\n        x: fx + blockSizeWidth - blockSizeHeight / 4,\r\n        y: fy + blockSizeHeight / 4,\r\n      },\r\n      { x: fx + blockSizeHeight / 4, y: fy + blockSizeHeight / 4 },\r\n    ];\r\n    const coordinatesInf = [\r\n      { x: fx, y: fy + blockSizeHeight },\r\n      { x: fx + blockSizeWidth, y: fy + blockSizeHeight },\r\n      {\r\n        x: fx + blockSizeWidth - blockSizeHeight / 4,\r\n        y: fy + blockSizeHeight - blockSizeHeight / 4,\r\n      },\r\n      {\r\n        x: fx + blockSizeHeight / 4,\r\n        y: fy + blockSizeHeight - blockSizeHeight / 4,\r\n      },\r\n    ];\r\n    const coordinatesLeft = [\r\n      { x: fx, y: fy },\r\n      { x: fx + blockSizeWidth / 4, y: fy + blockSizeWidth / 4 },\r\n      {\r\n        x: fx + blockSizeWidth / 4,\r\n        y: fy + blockSizeHeight - blockSizeWidth / 4,\r\n      },\r\n      { x: fx, y: fy + blockSizeHeight },\r\n    ];\r\n    const coordinatesRight = [\r\n      { x: fx + blockSizeWidth, y: fy },\r\n      {\r\n        x: fx + blockSizeWidth - blockSizeWidth / 4,\r\n        y: fy + blockSizeWidth / 4,\r\n      },\r\n      {\r\n        x: fx + blockSizeWidth - blockSizeWidth / 4,\r\n        y: fy + blockSizeHeight - blockSizeWidth / 4,\r\n      },\r\n      { x: fx + blockSizeWidth, y: fy + blockSizeHeight },\r\n    ];\r\n    this.drawPolygon(coordinatesSupp, \"#ffffff80\");\r\n    this.drawPolygon(coordinatesInf, \"#00000080\");\r\n    this.drawPolygon(coordinatesLeft, \"#00000050\");\r\n    this.drawPolygon(coordinatesRight, \"#00000050\");\r\n  }\r\n\r\n  /**\r\n   * Draw all the game and informations\r\n   */\r\n  drawGame() {\r\n    const darkColor = \"#212129\";\r\n\r\n    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\r\n\r\n    this.ctx.fillStyle = darkColor;\r\n    this.ctx.fillRect(0, 0, this.canvasWidth / 2, this.canvasHeight);\r\n\r\n    const boardMatrix = this.board.getBoard();\r\n\r\n    /* Drawing main board */\r\n    for (let i = 0; i < boardMatrix.length; ++i) {\r\n      for (let j = 0; j < boardMatrix[i].length; ++j) {\r\n        const isBorderGrid = boardMatrix[i][j] === 0;\r\n\r\n        if (isBorderGrid) {\r\n          this.drawBorder(j, i);\r\n          continue;\r\n        }\r\n        //We set -1 because 0 was reserved for empty\r\n        const color = colors[boardMatrix[i][j] - 1];\r\n        this.drawRect(j, i, color);\r\n      }\r\n    }\r\n\r\n    const textX = this.canvasWidth / 2 + 10;\r\n\r\n    /* Score */\r\n    this.ctx.fillStyle = darkColor;\r\n    this.ctx.font = \"20px Arial, sans-serif\";\r\n    this.ctx.fillText(\"Score: \" + this.board.getScore(), textX, 35);\r\n\r\n    /* Game status */\r\n    this.ctx.fillText(\"Game status:\", textX, 65);\r\n    this.ctx.fillText(\"> \" + this.gameStatus, textX, 85);\r\n\r\n    /* Next Shape */\r\n    this.ctx.fillText(\"Next Shape:\", textX, 115);\r\n    const nextShape = this.board.getNextShape().getShape();\r\n    for (let i = 0; i < nextShape.length; ++i) {\r\n      for (let j = 0; j < nextShape[i].length; ++j) {\r\n        const dontNeedDraw = nextShape[i][j] === 0;\r\n\r\n        if (dontNeedDraw) continue;\r\n\r\n        //We set -1 because 0 was reserved for empty\r\n        const color = colors[nextShape[i][j] - 1];\r\n        this.drawRect(j, i, color, textX, 125);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Method to call when we loose\r\n   */\r\n  loose() {\r\n    this.gameStatus = GameStatus.LOOSE;\r\n    this.drawGame();\r\n    this.reset(false);\r\n  }\r\n\r\n  /**\r\n   * Start the game/clock\r\n   */\r\n  start() {\r\n    if (!this.clock) {\r\n      this.gameStatus = GameStatus.PLAYING;\r\n      this.clock = setInterval(() => {\r\n        this.board.update();\r\n        this.drawGame();\r\n        if (this.board.haveLoose()) this.loose();\r\n      }, GAME_OPTIONS.TICK);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop the game/clock\r\n   */\r\n  stop() {\r\n    clearInterval(this.clock);\r\n    this.gameStatus = GameStatus.NOT_PLAYING;\r\n    this.clock = null;\r\n    // this.drawGame();\r\n  }\r\n\r\n  /**\r\n   * Reset the game\r\n   * @param withDraw\r\n   */\r\n  reset(withDraw = true) {\r\n    this.stop();\r\n    this.board.reset();\r\n    if (withDraw) this.drawGame();\r\n  }\r\n\r\n  /**\r\n   * Check if game is playing\r\n   * @returns\r\n   */\r\n  isRunning() {\r\n    return !!this.clock;\r\n  }\r\n\r\n  getBoard() {\r\n    return this.board;\r\n  }\r\n}\r\n\r\nexport default GameHandler;\r\n","import GameHandler from \"./core/GameHandler\";\r\n\r\nconst canvas = document.querySelector(\"canvas\");\r\nconst playBtn = document.querySelector(\"#play\");\r\nconst pauseBtn = document.querySelector(\"#pause\");\r\nconst resetBtn = document.querySelector(\"#reset\");\r\n\r\nconst game = new GameHandler(canvas);\r\n\r\nplayBtn.addEventListener(\"click\", () => game.start());\r\npauseBtn.addEventListener(\"click\", () => game.stop());\r\nresetBtn.addEventListener(\"click\", () => game.reset());\r\n"],"names":["colors","shapes","Shape","constructor","board","shape","position","this","downTick","x","Math","floor","getWidth","length","y","randomShape","rndShape","random","rotate","haveRotate","matrix","numRows","numCols","rotated","col","newRow","row","push","newY","newX","canRotateX","canRotateY","getHeight","structuredClone","getBoard","i","j","update","canGoLeft","checkY","undefined","_a","canGoRiht","canGoDown","haveReachedBottom","_b","_c","goDown","goRight","goLeft","getShape","getPosition","copy","Board","width","height","score","actualShape","nextShape","buildBoard","removeLastShapeDraw","backShape","displayShape","haveLoose","some","getScoreFromCompletedLine","completedLines","removeCompletedLines","every","splice","unshift","Array","fill","getScore","getActualShape","getNextShape","getBackShape","setActualShape","setNextShape","setBackShape","setBoard","setScore","reset","KeyHandler","gameHandler","keys","initKeyListener","document","addEventListener","event","isRunning","key","cmd","Object","entries","find","arr","toLocaleLowerCase","drawGame","loose","GameStatus","GAME_OPTIONS","RIGHT","DOWN","LEFT","ROTATE","canvas","querySelector","playBtn","pauseBtn","resetBtn","game","gameStatus","NOT_PLAYING","ctx","getContext","canvasWidth","canvasHeight","keyHandler","drawPolygon","coordinates","color","fillStyle","beginPath","moveTo","lineTo","closePath","drawBorder","blockSizeWidth","blockSizeHeight","strokeStyle","rect","stroke","drawRect","suppX","suppY","fx","fy","fillRect","coordinatesSupp","coordinatesInf","coordinatesLeft","coordinatesRight","darkColor","clearRect","boardMatrix","textX","font","fillText","LOOSE","start","clock","PLAYING","setInterval","stop","clearInterval","withDraw"],"mappings":"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"}